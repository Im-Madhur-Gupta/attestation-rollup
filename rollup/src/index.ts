import { ActionSchema, FIFOStrategy, MicroRollup } from "@stackr/stackr-js";
import bodyParser from "body-parser";
import express, { Request, Response } from "express";
import { stackrConfig } from "../stackr.config";
import { CounterRollup, counterSTF } from "./state";
import { StateMachine } from "@stackr/stackr-js/execution";
import axios from "axios";
import { v4 as uuidv4 } from 'uuid';

// this file is generated by the deployment script
import * as genesisState from "../genesis-state.json";

const BASE_URL = 'http://localhost:8081';
const INPUT_UPLOAD_URL_ROUTE = '/inputs/upload';
const INPUTS_ROUTE = '/inputs';
const SESSION_CREATE_ROUTE = '/sessions/create';
const SNARK_STATUS_ROUTE = '/snark/status';

const axiosInstance = axios.create({
  baseURL: BASE_URL
});

const INVERT_IMAGE_ID = '8420419c383551d6f4fffc8cb4f1dd5bd0667992a4a98079b5dd657d474622ff'

const rollup = async () => {
  const uri = ''
  const counterFsm = new StateMachine({
    state: new CounterRollup(genesisState.state),
    stf: counterSTF,
  });

  const actionSchemaType = {
    uuid: "String",
    operation: "String",
    proof: "String",
    updatedContent: "String",
    previousContent: "String"
  };

  const actionInput = new ActionSchema("edit-content", actionSchemaType);

  const buildStrategy = new FIFOStrategy();

  const { state, actions, events } = await MicroRollup({
    config: stackrConfig,
    useState: counterFsm,
    useAction: actionInput,
    useBuilder: { strategy: buildStrategy, autorun: true },
    useSyncer: { autorun: true },
  });

  return { state, actions };
};

const app = express();
app.use(bodyParser.json());
const { actions, state } = await rollup();

type ContentState = {
  uuid: string,
  operation: string
  proof: string
  updatedContent: string
  previousContent: string
}

const contentState: ContentState[] = []

const sleep = (ms: number) => {
  return new Promise(resolve => setTimeout(resolve, ms));
}

app.get("/", (req: Request, res: Response) => {
  res.send({ contentState });
});

app.post("/", async (req: Request, res: Response) => {

  const { operation, uuid, previousContent, updatedContent, proof } = req.body;

  const inputUploadResponse = await axiosInstance.get(INPUT_UPLOAD_URL_ROUTE)
  const inputUUID = inputUploadResponse.data.uuid;

  let config = {
    method: 'put',
    maxBodyLength: Infinity,
    url: `${BASE_URL}/${inputUUID}`,
    headers: { 
      'Content-Type': 'text/plain'
    },
    data : previousContent
  };

  const submitInputResponse = await axiosInstance.request(config);

  let snarkCreationData = JSON.stringify({
    "img": INVERT_IMAGE_ID,
    "input": inputUUID
  });
  
  config = {
    method: 'post',
    maxBodyLength: Infinity,
    url: `${BASE_URL}/sessions/create`,
    headers: { 
      'Content-Type': 'application/json'
    },
    data: snarkCreationData
  };
  
  const snarkCreationResponse = await axiosInstance.request(config);
  const snarkCreationSessionId = snarkCreationResponse.data.uuid;

  await sleep(4000); // waiting for 4 seconds

  config = {
    method: 'get',
    maxBodyLength: Infinity,
    url: `${BASE_URL}/snark/status/${snarkCreationSessionId}`,
    headers: { 
      'Content-Type': 'application/json'
    },
    data: ''
  };
  
  const snarkStatusResponse = await axiosInstance.request(config);

  const snarkStatusJournal = snarkStatusResponse.data.output.journal;
  // decode the journal here

  const journal = new Uint8Array(snarkStatusJournal);
  
  const decoder = new TextDecoder();
  
  const base64 = decoder.decode(journal);

  if(uuid) {
    // @ts-ignore
    const currentContentState = contentState.find(content => content.uuid === uuid)[0];
    contentState.push({
      uuid,
      updatedContent: base64,
      previousContent: currentContentState.updatedContent,
      proof: '',
      operation: 'invert'
    })
  } else {
    contentState.push({
      uuid: uuidv4(),
      updatedContent,
      previousContent,
      proof: '',
      operation: 'capture'
    })
  };

  res.status(201).send({
    'status': 'ok'
  });
});

app.listen(3000, () => {
  console.log("listening on port 3000");
});

// actionEventsEmitter.on(ActionEvents.SUBMIT_ACTION, (data) => {
//   console.log("submit_action - Event triggered : ", data.payload);
// });

// executorEventsEmitter.on(ExecutorEvents.EXECUTE_SINGLE, (data) => {
//   console.log("execute_single - Event triggered : ", data);
// });
